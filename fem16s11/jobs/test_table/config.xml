<flow-definition plugin="workflow-job@2.25">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition@1.3.2"/>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition@1.3.2">
      <jobProperties/>
      <triggers/>
      <parameters/>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description>ENM Cloud Native Upgrade Build pipeline MT_cENM_Upgrade_Functional - autogenerated using JobDSL - all manual changes will be overwritten!</description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.plugins.buildblocker.BuildBlockerProperty plugin="build-blocker-plugin@1.7.3">
      <useBuildBlocker>false</useBuildBlocker>
      <blockLevel>GLOBAL</blockLevel>
      <scanQueueFor>DISABLED</scanQueueFor>
      <blockingJobs/>
    </hudson.plugins.buildblocker.BuildBlockerProperty>
    <com.ericsson.duraci.messaging.ImplicitMessagingContributorProperty plugin="eiffel-core@69.0.3">
      <scriptEnabled>false</scriptEnabled>
    </com.ericsson.duraci.messaging.ImplicitMessagingContributorProperty>
    <jenkins.model.BuildDiscarderProperty>
      <strategy class="hudson.tasks.LogRotator">
        <daysToKeep>-1</daysToKeep>
        <numToKeep>30</numToKeep>
        <artifactDaysToKeep>-1</artifactDaysToKeep>
        <artifactNumToKeep>-1</artifactNumToKeep>
      </strategy>
    </jenkins.model.BuildDiscarderProperty>
    <com.sonyericsson.jenkins.plugins.bfa.model.ScannerJobProperty plugin="build-failure-analyzer@1.19.2">
      <doNotScan>false</doNotScan>
    </com.sonyericsson.jenkins.plugins.bfa.model.ScannerJobProperty>
    <org.jenkinsci.plugins.workflow.job.properties.DisableConcurrentBuildsJobProperty/>
    <com.ericsson.duraci.messaging.ImplicitEiffelMessagingJobProperty plugin="eiffel-core@69.0.3">
      <messagingEnabled>false</messagingEnabled>
      <jobFinishedDisabled>false</jobFinishedDisabled>
    </com.ericsson.duraci.messaging.ImplicitEiffelMessagingJobProperty>
    <com.sonyericsson.rebuild.RebuildSettings plugin="rebuild@1.29">
      <autoRebuild>false</autoRebuild>
      <rebuildDisabled>false</rebuildDisabled>
    </com.sonyericsson.rebuild.RebuildSettings>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>environment_name</name>
          <description>Deployment name of cENM Cloud Deployment to be Upgraded</description>
          <defaultValue/>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <org.jvnet.jenkins.plugins.nodelabelparameter.LabelParameterDefinition plugin="nodelabelparameter@1.7.2">
          <name>SLAVE</name>
          <description/>
          <defaultValue>Jenkins_Upgrade_CSAR_Slave_4Node_MISTY_3</defaultValue>
          <allNodesMatchingLabel>false</allNodesMatchingLabel>
          <triggerIfResult>allCases</triggerIfResult>
          <nodeEligibility class="org.jvnet.jenkins.plugins.nodelabelparameter.node.AllNodeEligibility"/>
        </org.jvnet.jenkins.plugins.nodelabelparameter.LabelParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@2.57.2">
    <script>#!/usr/bin/env groovy

/* In order to make this pipeline work, the following configuration on Jenkins is required:
 * - slave with a specific label (see pipeline.agent.label below)
 * - credentials plugin should be installed and have the secrets with the following names:
 */


/* 
 * This function is required to capture the status of healthy pods
 */

def checkHealthyPods() {
    desiredStatefulset = sh ( script: "${kubectl} -n ${NAMESPACE} get sts    | grep -v 'NAME' | awk -F' ' '{stssum += \$2} END {print stssum}'", returnStdout: true ).trim()
    echo "${desiredStatefulset}"
    desiredDeployment  = sh ( script: "${kubectl} -n ${NAMESPACE} get deploy | grep -v 'NAME' | awk -F' ' '{depsum += \$2} END {print depsum}'", returnStdout: true ).trim()
    echo "${desiredDeployment}"
    currentHealthyPods = sh ( script: "${kubectl} -n ${NAMESPACE} get pods   | grep -v 'NAME' | grep 'Running' | awk -F' ' '{print \$2}' | awk -F'/' '{podsum += \$1} END {print podsum}'", returnStdout: true ).trim()
    echo "${currentHealthyPods}"
    desiredDeploy=desiredDeployment.toInteger()
    currentHealthy=currentHealthyPods.toInteger()
    desiredStateful=desiredStatefulset.toInteger()

    if ( desiredStateful + desiredDeploy &lt;= currentHealthy ) {
        echo "Desired:Statefulset + Desired:Deployment is lesser than or equal to Current: Running Healthy Pods"
    } else {
        echo "Desired:Statefulset + Desired:Deployment is not matching Current: Running Healthy Pods"
        sh "sleep 60"
        sh "exit 1"
    }
}

/* 
 * This function will captures the report of the deployment and sends the report through mail
 */

def emailReport(content){

    def subject = "${env.JOB_NAME} - Build #${env.BUILD_NUMBER} - ${currentBuild.currentResult}!"

    try {
        emailext(body: content, mimeType: 'text/html', from: 'jenkins_monitoring@ericsson.com',
            subject: subject,
            to: "udaya.boyina@tcs.com" )
    } catch( err ){
        echo "$err"
    }
}

/* 
 * This function will generates report of the deployment.
 */

def reportHeading(status){

    def deployResult
    def color
    def investigation

    if(status == 'Success'){
        deployResult = "Success"
        color = "#9ACD32"
        investigation = "NA"
    } else if(status == 'Failed'){
        deployResult = "Failed"
        color = "#DC143C"
        investigation = "(If applicable), will be included in a follow up email"
    } else if(status == 'Aborted'){
        deployResult = "Aborted"
        color = "#95A5A6"
        investigation = "(If applicable), will be included in a follow up email"
    }

    def report = "Hi All,\n\n &lt;h2&gt;${environment_name} Deployment Result: &lt;span style=\"background-color:${color};\"&gt;${status}&lt;/span&gt;&lt;/h2&gt;"
    def BrochartVersion = sh (script : "${helm} list -n ${NAMESPACE} | grep eric-enm-bro-integration-${NAMESPACE} | awk \'{print \$(NF-1)}\'", returnStdout: true)
    def PredeploychartVersion = sh (script : "${helm} list -n ${NAMESPACE} | grep eric-enm-pre-deploy-integration-${NAMESPACE} | awk \'{print \$(NF-1)}\'", returnStdout: true)
    def InfrachartVersion = sh (script : "${helm} list -n ${NAMESPACE} | grep eric-enm-infra-integration-${NAMESPACE} | awk \'{print \$(NF-1)}\'", returnStdout: true)
    def StatelesschartVersion = sh (script : "${helm} list -n ${NAMESPACE} | grep eric-enm-stateless-integration-${NAMESPACE} | awk \'{print \$(NF-1)}\'", returnStdout: true)
    report += " &lt;ul&gt;&lt;li&gt;&lt;strong&gt;Login URL :&lt;/strong&gt; &lt;a href=https://${ENM_LAUNCHER_HOSTNAME}/login&gt; https://${ENM_LAUNCHER_HOSTNAME}/login &lt;/a&gt;&lt;/li&gt;"
    report += "&lt;li&gt;&lt;strong&gt;Bro Chart version :&lt;/strong&gt; ${BrochartVersion}&lt;/li&gt;"
    report += "&lt;li&gt;&lt;strong&gt;Pre Deploy Chart version :&lt;/strong&gt; ${PredeploychartVersion}&lt;/li&gt;"
    report += "&lt;li&gt;&lt;strong&gt;Infra Chart version :&lt;/strong&gt; ${InfrachartVersion}&lt;/li&gt;"
    report += "&lt;li&gt;&lt;strong&gt;Stateless Chart version :&lt;/strong&gt; ${StatelesschartVersion}&lt;/li&gt;"
    report += "&lt;li&gt;&lt;strong&gt;Please find the Deployment Job Details:&lt;/strong&gt;  &lt;a href=${BUILD_URL}&gt;${BUILD_URL}&lt;/a&gt;&lt;/li&gt;"
    report += "&lt;li&gt;&lt;strong&gt;Investigation Results : ${investigation} &lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;"


    report = report.replace("\n","&lt;/br&gt;")
    return report
}

/* 
 * This function will print the list of unstable pods after Upgrade
 */

def printPods(){
    def RestartPods = sh (script : "\${kubectl} -n \${NAMESPACE} get pods --sort-by=\'.status.containerStatuses[0].restartCount\' --no-headers  | awk \'\$4&gt;0 {print \$0}\'", returnStdout: true)
    def failedState = sh (script : "${kubectl} -n ${NAMESPACE} get pods | egrep \'NAME|Running\' | egrep \'0/|NAME\'" , returnStdout: true)
    def initState = sh (script : "${kubectl} -n ${NAMESPACE} get pods | grep -v Running |grep -v Completed || true", returnStdout: true)
    def sidecarhttpd= sh (script : "${kubectl} -n ${NAMESPACE} get pods | egrep \'NAME|Running\' | egrep \'1/2|NAME\'" , returnStdout: true)
    def sidecarmonitoring= sh (script : "${kubectl} -n ${NAMESPACE} get pods | egrep \'NAME|Running\' | egrep \'2/3|NAME\'" , returnStdout: true)
    def report(){
	  for line in ${RestartPods}
	  echo ${line}
	}
    echo "${report}"
    report = report.replace("\n","&lt;/br&gt;")
    report += "&lt;style&gt; pre {display: block;font-family: Lucida Console, Monaco, monospace; white-space: pre;} &lt;/style&gt;";

    return report
}

/* 
 * This function is required to check if the integration parameters  exists in integration values.yaml file or not.
 */

def integration_values_file_keys_exists(element, keys,value){
     def str = keys.tokenize(".");
    _element = element
    _flag = false
     for (i = 0; i &lt; str.size(); i++) {
        try{
           if ( _element!=null&amp;&amp;_element.containsKey(str[i])){
              _element = _element[str[i]]
              if(i==str.size()-1){
                _flag=true
              }
           }
           } catch( err ) {
              return false
            }
        }
         return  _flag
}

/* 
 * This function will update value of the key in integration values.yaml file.
 */
 
def update_IntegrationValues_with_values(keys,value){
     def str = keys.tokenize(".");
     def bindings = [:]
     def map = bindings
     for (i = 0; i &lt; str.size(); i++) {
       def part = str[i];
       if (!map.containsKey(part)) {
           map[part] = values.get(part)
       }
       if (i == str.size() - 1) {
           map[part] = value
       } else {
          map = map[part]
       }
     }
    values.putAll(bindings)
}

/* 
 * This function is required to Update the integration values.yaml file with site-config properties
 */

def updateIntegrationValues() {
    try {
        def integration_value_map = [
                       'global.registry.url':'TARGET_DOCKER_REGISTRY_URL',
                       'global.registry.pullSecret':'PULLSECRET',
                       'global.persistentVolumeClaim.storageClass':'STORAGE_CLASS',
                       'global.ingress.enmHost':'ENM_LAUNCHER_HOSTNAME',
                       'global.enmProperties.COM_INF_LDAP_ROOT_SUFFIX':'COM_INF_LDAP_ROOT_SUFFIX',
                       'global.enmProperties.COM_INF_LDAP_ADMIN_CN':'COM_INF_LDAP_ADMIN_CN',
                       'global.rwx.storageClass':'RWX_STORAGE_CLASS',
                       'global.timezone':'TIME_ZONE',
                       'global.enmProperties.host_system_identifier':'HOST_SYSTEM_IDENTIFIER',
                       'eric-data-graph-database-nj.persistentVolumeClaim.storageClass':'STORAGE_CLASS',
                       'eric-data-graph-database-nj.persistentVolumeClaim.backup.storageClass':'STORAGE_CLASS',
                       'eric-data-graph-database-nj.persistentVolumeClaim.logging.storageClass':'STORAGE_CLASS',
                       'global.vips.fm_vip_address':'FM_VIP_ADDRESS',
                       'global.vips.cm_vip_address':'CM_VIP_ADDRESS',
                       'global.vips.pm_vip_address':'PM_VIP_ADDRESS',
                       'global.vips.amos_vip_address':'AMOS_VIP_ADDRESS',
                       'global.vips.general_scripting_vip_address':'SCRIPT_VIP_ADDRESS',
                       'global.vips.element_manager_vip_address':'ELEMENT_MANAGER_VIP',
                       'global.vips.ui_vip_address':'UI_VIP_ADDRESS',
                       'global.vips.visinamingsb_vip_address':'CM_VIP_ADDRESS',
                       'eric-ctrl-bro.persistence.persistentVolumeClaim.storageClassName':'STORAGE_CLASS'
                       ]
        def list_all_environment = env.getEnvironment()
       filename = "${HOME_DIR}/cENM/Scripts/${integration_values_file}"
       values = readYaml file: filename
       for (parameter in integration_value_map){
         def value = parameter.value
         def key = parameter.key
         if (integration_values_file_keys_exists( values, key, value)){
               if ( value == "TARGET_DOCKER_REGISTRY_URL"){
                   value="TARGET_DOCKER_REGISTRY_URL_WITH_OUT_PORT"
               }
               value= list_all_environment.get(value)
               update_IntegrationValues_with_values(key,value)
         }
       }

        sh "rm -f ${filename}"
        writeYaml file: filename, data: values
    } catch( err ) {
        echo "$err"
        sh "exit 1"
    }
}

/* 
 * This function is required to download the integration charts and integration values file from CI Internal area which can be used by * both Integration and MT teams.
 */

def download_charts_ci_internal(){
  try{
          sh "curl ${helm_repository_ci_internal}/eric-enm-bro-integration/eric-enm-bro-integration-${BRO_CHART_VERSION}.tgz -o cENM/Definitions/OtherTemplates/eric-enm-bro-integration-${BRO_CHART_VERSION}.tgz"
          sh "curl ${helm_repository_ci_internal}/eric-enm-pre-deploy-integration/eric-enm-pre-deploy-integration-${PRE_DEPLOY_CHART_VERSION}.tgz -o cENM/Definitions/OtherTemplates/eric-enm-pre-deploy-integration-${PRE_DEPLOY_CHART_VERSION}.tgz"
          sh "curl ${helm_repository_ci_internal}/eric-enm-infra-integration/eric-enm-infra-integration-${INFRA_CHART_VERSION}.tgz -o cENM/Definitions/OtherTemplates/eric-enm-infra-integration-${INFRA_CHART_VERSION}.tgz"
          sh "curl ${helm_repository_ci_internal}/eric-enm-stateless-integration/eric-enm-stateless-integration-${STATELESS_CHART_VERSION}.tgz -o cENM/Definitions/OtherTemplates/eric-enm-stateless-integration-${STATELESS_CHART_VERSION}.tgz"
          sh "curl ${helm_repository_ci_internal}/eric-enm-integration-values/eric-enm-integration-production-values-${INTEGRATION_VALUE_VERSION}.yaml -o cENM/Scripts/eric-enm-integration-production-values-${INTEGRATION_VALUE_VERSION}.yaml"
     }catch( err ) {
        echo "$err"
        sh "exit 1"
      }
}

/* 
 * This function is required to download the integration charts and integration values file from drop area which can be used by
 * both Integration and MT teams.
 */

def download_charts_release_area(){
  try{
          sh "curl ${helm_repository_release}/eric-enm-bro-integration/eric-enm-bro-integration-${BRO_CHART_VERSION}.tgz -o cENM/Definitions/OtherTemplates/eric-enm-bro-integration-${BRO_CHART_VERSION}.tgz"
          sh "curl ${helm_repository_release}/eric-enm-pre-deploy-integration/eric-enm-pre-deploy-integration-${PRE_DEPLOY_CHART_VERSION}.tgz -o cENM/Definitions/OtherTemplates/eric-enm-pre-deploy-integration-${PRE_DEPLOY_CHART_VERSION}.tgz"
          sh "curl ${helm_repository_release}/eric-enm-infra-integration/eric-enm-infra-integration-${INFRA_CHART_VERSION}.tgz -o cENM/Definitions/OtherTemplates/eric-enm-infra-integration-${INFRA_CHART_VERSION}.tgz"
          sh "curl ${helm_repository_release}/eric-enm-stateless-integration/eric-enm-stateless-integration-${STATELESS_CHART_VERSION}.tgz -o cENM/Definitions/OtherTemplates/eric-enm-stateless-integration-${STATELESS_CHART_VERSION}.tgz"
          sh "curl ${helm_repository_release}/eric-enm-integration-values/eric-enm-integration-production-values-${INTEGRATION_VALUE_VERSION}.yaml -o cENM/Scripts/eric-enm-integration-production-values-${INTEGRATION_VALUE_VERSION}.yaml"
     }catch( err ) {
        echo "$err"
        sh "exit 1"
      }
}

/* 
 * This function is required to get the charts and integration values file from respective folder which will be used in the Upgrade 
 * stage
 */

def get_integration_charts_version() {
    env.bro_integration_chart = sh (script: "ls cENM/Definitions/OtherTemplates/ |grep eric-enm-bro-integration*", returnStdout: true ).trim()
    env.pre_deploy_integration_chart = sh (script: "ls cENM/Definitions/OtherTemplates/ |grep eric-enm-pre-deploy-integration*", returnStdout: true ).trim()
    env.infra_integration_chart = sh (script: "ls cENM/Definitions/OtherTemplates/ |grep eric-enm-infra-integration*", returnStdout: true ).trim()
    env.stateless_integration_chart = sh (script: "ls cENM/Definitions/OtherTemplates/ |grep eric-enm-stateless-integration*", returnStdout: true ).trim()
    env.integration_values_file=sh (script: "ls cENM/Scripts |grep eric-enm-integration-production-values*", returnStdout: true ).trim()
}

/* 
 *This function is required to read the values from the Site-Config-File of specified deployment.
 */

def read_site_config_file(){
    def site_config_properties = readProperties  (file:"Site-Config-File/${environment_name}")
    env.KUBE_CRED = site_config_properties['KUBE_CRED']
    env.NAMESPACE = site_config_properties['NAMESPACE']
    env.RWX_STORAGE_CLASS =site_config_properties['RWX_STORAGE_CLASS']
    env.STORAGE_CLASS =site_config_properties['STORAGE_CLASS']
    env.TIME_ZONE=site_config_properties['TIME_ZONE']
    env.HOST_SYSTEM_IDENTIFIER = site_config_properties['HOST_SYSTEM_IDENTIFIER']
    env.ENM_LAUNCHER_HOSTNAME=site_config_properties['ENM_LAUNCHER_HOSTNAME']
    env.EMAIL_LIST=site_config_properties['EMAIL_LIST']
    env.COM_INF_LDAP_ROOT_SUFFIX= site_config_properties['COM_INF_LDAP_ROOT_SUFFIX']
    env.COM_INF_LDAP_ADMIN_CN=site_config_properties['COM_INF_LDAP_ADMIN_CN']
    env.FM_VIP_ADDRESS = site_config_properties['FM_VIP_ADDRESS']
    env.CM_VIP_ADDRESS = site_config_properties['CM_VIP_ADDRESS']
    env.PM_VIP_ADDRESS = site_config_properties['PM_VIP_ADDRESS']
    env.AMOS_VIP_ADDRESS = site_config_properties['AMOS_VIP_ADDRESS']
    env.ELEMENT_MANAGER_VIP = site_config_properties['ELEMENT_MANAGER_VIP']
    env.SCRIPT_VIP_ADDRESS = site_config_properties['SCRIPT_VIP_ADDRESS']
    env.UI_VIP_ADDRESS = site_config_properties['UI_VIP_ADDRESS']
    env.VISINAMINGSB_VIP_ADDRESS = site_config_properties['CM_VIP_ADDRESS']
    env.kubeConfig = "${workspace}/.kube/${KUBE_CRED}"
    env.helm = "docker run --rm -v ${kubeConfig}:/root/.kube/config -v ${WORKSPACE}:${WORKSPACE} --workdir ${WORKSPACE} ${cenm_utilities_docker_image} helm3"
    env.kubectl = "docker run --rm  -v ${kubeConfig}:/root/.kube/config -v ${WORKSPACE}:${WORKSPACE} --workdir ${WORKSPACE} ${cenm_utilities_docker_image} kubectl"

}

/* 
 *This function is required to Check whether ENM launcher page is opening or not.
 */

def smokeTest() {
    response = sh (script: "curl --insecure -X POST -d \"IDToken1=Administrator&amp;IDToken2=TestPassw0rd\" https://${ENM_LAUNCHER_HOSTNAME}/login -H \"Content-Type: application/x-www-form-urlencoded\" -H \"Accept-Encoding: gzip,deflate\" -H \"Accept: */*\" -L -H \'cache-control: no-cache\'", returnStdout: true ).trim()
    echo response
    if ( response.contains("Authentication Successful") ){
       echo "Success! Can login to ENM"
    } else {
       echo "Failed! Can\'t login to ENM"
       sh "exit 1"
    }
}

pipeline{
    agent {
            node
            {
            label SLAVE
            }
        }
    options {
        timeout(time: 4, unit: 'HOURS')
    }
    environment {
        HOME_DIR = "${WORKSPACE}"
        https_proxy = "http://www-proxy.lmera.ericsson.se:8080/"
        cenm_utilities_docker_image = "armdocker.rnd.ericsson.se/proj-enm/cenm-build-utilities:latest"
        nexus_repositoryUrl = "https://arm902-eiffel004.athtem.eei.ericsson.se:8443/nexus/content/repositories/releases/"
        helm_repository_release = "https://arm.seli.gic.ericsson.se/artifactory/proj-enm-helm/"
        helm_repository_ci_internal = "https://arm.seli.gic.ericsson.se/artifactory/proj-enm-dev-internal-helm/"
        CSAR_PACKAGE_NAME = "enm-installation-package"
    }
    stages{
        stage('Clean Up WorkSpace'){
                steps{
                        deleteDir()
                     }
        }
        stage('Checkout Integration Pipeline Git Repository') {
            steps {
                git branch: 'master',
                        url: 'ssh://gerrit.ericsson.se:29418/OSS/com.ericsson.oss.containerisation/eric-enm-integration-pipeline-code'
            }
        }

        stage( 'Site Config Properties' ) {
            steps {
                 script{
                         read_site_config_file()
                      }
              }
        }
        stage( 'Pre Configurations' ) {
            steps {
                   sh 'mkdir -p ${PWD}/.kube &amp;&amp; chmod 775 ${PWD}/.kube &amp;&amp; cp -v ${PWD}/Kube-Config-Files/${KUBE_CRED} ${PWD}/.kube/${KUBE_CRED} &amp;&amp; chmod 664 ${PWD}/.kube/${KUBE_CRED}'

            }
        }
    }
    post{
        failure {
            script{
                echo "Failure"
                def report = reportHeading("Failed")
                report += printPods()
                emailReport(report)
            }
        }
        aborted{
            script{
                echo "Aborted"
                def report = reportHeading("Aborted")
                report += printPods()
                emailReport(report)
            }
        }
        success{
            script{
                echo "Success"
                def report = reportHeading("Success")
                report +=printPods()
                emailReport(report)
            }
        }
    }
}
</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>true</disabled>
</flow-definition>